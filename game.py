"""
A train simulator.

The world is randomly generated by the `railway` module, first as an abstract
description of the railway, and then into a 2D graph consisting of all needed
train tracks. The generation can be paused and resumed when needed, so the
game map can be extended as is necessary. A subgraph of the whole railway
network, which is in the player's field of view, is converted into 3D meshes
by the `meshes` module. This module is also responsible for the procedural
generation of the train's mesh. The train's position on the graph is tracked
by the `train` module. The train can only move along the main track. The
`section` and `scores` modules handle the gameplay. `ui` and `menu` are used
to draw the user interface, `g3d` is responsible for the rendering. `util`
contains frequently used functions and `game_time` is used for time-keeping
with more flexibility than the pygame's tick counter.
"""
import pygame
import random
import sys
import math

import g3d
import ui
import railway
import train
import meshes
import section
import game_time
import scores
import menu

from meshes import generate_track, generate_station, generate_props
from meshes import generate_signal, generate_train
from util import parper2

WINDOW_SIZE = (1280, 720)
FPS = 60  # Upper frames per second limit

STATION_DELAY = 2  # seconds after stop before the approach counters are hidden
PASSENGERS_DELAY = 4  # seconds after stop before the summary is shown

# The subset of the railway which is rendered starts RANGE[0] vertices
# behind the front of the train and ends RANGE[1] vertices forward
# from that point.
MAP_MESH_RANGE = (8, 20)

GROUND_COLOR = (173, 201, 105)

train_acceleration = {  # For each power level
    3: 22,
    2: 10,
    1: 0,
    0: -6,
    -1: -17,
    -2: -35,
    -3: -56
}


def lerp(a, b, w):
    """
    Interpolate between two values (a, b) by a weight w.
    """
    return a + w * (b - a)


def clamp(x, low, high):
    """
    Returns value x clamped to low and high.
    """
    if x < low:
        x = low
    elif x > high:
        x = high
    return x


# Workaround for older pygame versions
pygame.math.clamp = clamp
pygame.math.lerp = lerp


def get_offset():
    """
    Return the offset of the train head.
    """
    return (
        railway.railway_distance[railway.graph_index[train_position[1][-2]]]
        + train_position[0]
    ) / 30


def get_signal():
    """
    Return the next signal. The returned tuple contains the position of the
    next signal (in metres from the beginning of the track), its type, the
    aspect, and the distant aspect. Update the aspect of the stop signal
    after a station, at appropriate moment.
    """
    global current_signal, speed_limit, skipped
    global sigviol, power_lock, power_level
    position = railway.railway_distance[
        railway.signal_index[current_signal]]/30
    if get_offset() - position > 0:
        if (railway.signal_aspect[current_signal] == railway.SA_STOP
                and not autoplay and not sigviol):
            sigviol = True
            power_lock = True
            power_level = -3
            sect.penalty()
            sect.calculate_score(get_offset())
            session_score.add(sect.score)
    if get_offset() - position > 10 and not sigviol:
        speed_limit = railway.railway_speed[
                        railway.signal_index[current_signal]]
        current_signal += 1
        skipped = False
        position = railway.railway_distance[
            railway.signal_index[current_signal]]/30
    if (railway.signal_aspect[current_signal] == railway.SA_STOP
            and sect.stage == section.S_STOPPED
            or (skipped and train_velocity == 0)):
        railway.signal_aspect[current_signal] = max(
            railway.signal_aspect[current_signal + 1] - 1,
            railway.SA_PROCEED
        )
    distant_aspect = railway.SA_PROCEED
    for i in range(current_signal + 1, len(railway.signal_index)):
        dist = railway.railway_distance[railway.signal_index[i]]/30 - position
        if dist > 350:
            break
        distant_aspect = max(distant_aspect, railway.signal_aspect[i])

    return (position, railway.signal_type[current_signal],
            railway.signal_aspect[current_signal], distant_aspect)


def pause_game(value):
    """
    Open the pause screen.
    """
    global pause_frozen, paused
    if value:
        pause_frozen = game_time.frozen
        game_time.freeze()
        paused = True
    else:
        game_time.toggle_freeze(pause_frozen)
        paused = False


def end_game():
    """
    End the game.
    """
    global playing
    game_finalize()
    playing = False


def draw():
    """
    Draw everything on the screen.
    """
    global session_score, power_lock, power_level, sect, playing
    if autoplay:
        window.fill("white")
    else:
        window.fill(GROUND_COLOR)

    # World

    if autoplay:
        g3d.render_wireframe = True
        for i in range(len(g3d.triangle)):
            g3d.tri_color[i] = (230, 230, 230)
    g3d.render()
    if not autoplay and (g3d.render_wireframe or not g3d.render_solid):
        g3d.display_stats()

    # User interface

    if not autoplay and not paused:
        ui.draw_power_level(power_level)
        ui.draw_velocity(
            train_velocity*0.12,
            speed_limit
        )
        sig_pos, sig_typ, sig_asp, sig_dst = get_signal()
        ui.draw_signal(
            sig_pos - get_offset(),
            sig_asp,
        )
        ui.draw_next(sect.remaining_distance(get_offset()),
                     sect.predicted_time, game_time.now())
        show_approach = (
            sect.stage == section.S_APPROACH
            or sect.stage == section.S_BADSTOP
        )
        if sect.stage == section.S_STOPPED:
            seconds = (pygame.time.get_ticks() - sect.stage_update) / 1000
            if seconds < STATION_DELAY:
                show_approach = True
            elif seconds < PASSENGERS_DELAY:
                ui.display_passengers()
            else:
                if ui.draw_score(sect.score):
                    session_score.add(sect.score)
                    sect.advance()
                    power_lock = False
                    power_level = 0
                    game_time.unfreeze()
        if show_approach:
            ui.draw_approach(sect.approach_distances(get_offset())[2],
                             sect.predicted_time, game_time.now())
        ui.display_pushed_notification()
        if sigviol:
            ui.display_sigviol()
            if pygame.key.get_pressed()[pygame.K_SPACE]:
                end_game()

    if autoplay:
        window.blit(overlay, window_rect)
        if menu.draw():
            playing = True

    if paused:
        window.blit(overlay, window_rect)
        pause_state = menu.draw_pause()
        if pause_state is not None:
            if pause_state is True:
                end_game()
            else:
                pause_game(False)

    pygame.display.flip()


def handle_events():
    """
    Handle pygame events.
    """
    global power_level
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            end_game()
            session_score.calculate()
            score_history.end_session()
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.dict["key"] == pygame.K_z:
                g3d.toggle_debug_render()
            elif event.key == pygame.K_w and not power_lock:
                power_level = min(power_level + 1, 3)
            elif event.key == pygame.K_s and not power_lock:
                power_level = max(power_level - 1, -3)
            elif event.key == pygame.K_ESCAPE and playing:
                if sect.stage != section.S_STOPPED or paused:
                    pause_game(not paused)


def submap_push(index):
    """
    Add a railway index to the rendered submap (generate the required meshes).
    """
    branch_vertices = []
    v1 = railway.get_railway_vertex(index)
    for (v2, draw, is_main) in railway.graph_connections[v1]:
        if not draw:
            continue
        if is_main:
            if railway.graph_station[v1] is not None:
                generate_track(
                    index,
                    railway.graph_vertex[v1],
                    railway.graph_vertex[v2]
                )
                generate_station(
                    index,
                    railway.graph_vertex[v1],
                    railway.graph_vertex[v2],
                    roof=not autoplay
                )
                generate_props(
                    index,
                    railway.graph_vertex[v1],
                    railway.graph_vertex[v2],
                    120, 500
                )
            else:
                generate_track(
                    index,
                    railway.graph_vertex[v1],
                    railway.graph_vertex[v2]
                )
                generate_props(
                    index,
                    railway.graph_vertex[v1],
                    railway.graph_vertex[v2],
                    80, 500
                )
            if railway.railway_signal[railway.graph_index[v1]] is not None:
                generate_signal(
                    index,
                    railway.graph_vertex[v1],
                    railway.graph_vertex[v2]
                )
        elif railway.graph_index[v2] is None:
            generate_track(
                index,
                railway.graph_vertex[v1],
                railway.graph_vertex[v2]
            )
            branch_vertices.append(v1)
    for (in1, draw, is_main) in railway.graph_incoming[v1]:
        if not draw:
            continue
        if railway.graph_index[in1] is None:
            generate_track(
                index,
                railway.graph_vertex[v1],
                railway.graph_vertex[in1]
            )
            branch_vertices.append(in1)
    v2_back = railway.get_railway_vertex(index + 1, -1)
    for (v1_back, draw, is_main) in railway.graph_connections[v2_back]:
        if v1_back == v1 and v2_back == v2:
            if not autoplay:
                generate_props(
                    index,
                    railway.graph_vertex[v2],
                    railway.graph_vertex[v1],
                    80, 500, True
                )
            continue
        if not draw or is_main:
            continue
        if railway.graph_index[v1_back] is not None:
            if railway.graph_station[v1] is not None:
                generate_track(
                    index,
                    railway.graph_vertex[v2_back],
                    railway.graph_vertex[v1_back]
                )
                generate_station(
                    index,
                    railway.graph_vertex[v2_back],
                    railway.graph_vertex[v1_back],
                    roof=not autoplay
                )
                if not autoplay:
                    generate_props(
                        index,
                        railway.graph_vertex[v2_back],
                        railway.graph_vertex[v1_back],
                        120, 500, True
                    )
            else:
                generate_track(
                    index,
                    railway.graph_vertex[v2_back],
                    railway.graph_vertex[v1_back]
                )
                if not autoplay:
                    generate_props(
                        index,
                        railway.graph_vertex[v2_back],
                        railway.graph_vertex[v1_back],
                        80, 500, True
                    )
            for (in2, draw, is_main) in railway.graph_incoming[v1_back]:
                if not draw:
                    continue
                if railway.graph_index[in2] is None:
                    generate_track(
                        index,
                        railway.graph_vertex[v1_back],
                        railway.graph_vertex[in2]
                    )
                    branch_vertices.append(in2)
        else:
            generate_track(
                index,
                railway.graph_vertex[v2_back],
                railway.graph_vertex[v1_back]
            )
            branch_vertices.append(v1_back)
    done = set()
    while len(branch_vertices) != 0:
        bv1 = branch_vertices.pop()
        done.add(bv1)
        for (bv2, draw, is_main) in railway.graph_connections[bv1]:
            if bv2 in done:
                continue
            if railway.graph_index[bv2] is None:
                generate_track(
                    index,
                    railway.graph_vertex[bv1],
                    railway.graph_vertex[bv2]
                )
                branch_vertices.append(bv2)
        for (bv2, draw, is_main) in railway.graph_incoming[bv1]:
            if bv2 in done:
                continue
            if railway.graph_index[bv2] is None:
                generate_track(
                    index,
                    railway.graph_vertex[bv1],
                    railway.graph_vertex[bv2]
                )
                branch_vertices.append(bv2)


def submap_pop(index):
    """
    Remove a railway index from the rendered submap.
    """
    if index in meshes.railway_triangles:
        for tri in meshes.railway_triangles[index]:
            g3d.free_triangle(tri)


def submap_next(index=None):
    """
    Call this with the railway index of the node on which the
    last car is positioned. This function generates the railway
    when needed and updates which subset of the graph needs to
    be displayed.
    """
    global last_car_index
    while last_car_index < index:
        submap_pop(last_car_index - MAP_MESH_RANGE[0])
        if (last_car_index + MAP_MESH_RANGE[1] + 1500
                > len(railway.railway_angle)):
            for i in range(2000):
                next(rgen)
            next(ggen)
        submap_push(last_car_index + MAP_MESH_RANGE[1])
        last_car_index += 1


def update_map(init=False):
    """
    Update the game map.
    """
    global rgen, ggen, last_car_index
    if init:
        rgen = railway.generate_railway()
        ggen = railway.generate_graph()
        last_car_index = -MAP_MESH_RANGE[1]
        for i in range(2000):
            next(rgen)
        next(ggen)
    else:
        frontv = train_position[1][-1]
        fronti = railway.graph_index[frontv]
        if fronti is not None:
            submap_next(fronti)


def update_train(init=False):
    """
    Update the train state.
    """
    global train_position, train_velocity, power_level
    global power_lock, last_physics_update
    global current_signal, speed_limit, skipped
    global sect
    if init:
        train_position = train.place_train()
        train.advance_train(train_position, train.train_length)
        train_velocity = 0
        power_level = 0
        last_physics_update = pygame.time.get_ticks()
        current_signal = 0
        speed_limit = 40
        sect = section.Section(None)
        power_lock = False
        skipped = False
    dt = (pygame.time.get_ticks() - last_physics_update)/1000
    if game_time.frozen:
        dt = 0
    acceleration = train_acceleration[power_level]
    train_velocity += acceleration * dt
    train_velocity = max(0, train_velocity)
    train_velocity = min(1100, train_velocity)
    if autoplay:
        train_velocity = 900
    dx = train_velocity * dt
    train.advance_train(train_position, dx)
    last_physics_update = pygame.time.get_ticks()


def update_camera(focus, forward):
    """
    Update the position of the camera. Focus is the 3D point towards which the
    camera is oriented, and forward is a 2D vector pointing forward.
    In the menu autoplay mode, the camera is rotated to showcase the whole train
    from the side.
    """
    if autoplay:
        par = [forward[1], -forward[0]]
        g3d.camera_position = focus
        g3d.camera_position[2] += 50
        g3d.camera_position[0] -= 50*forward[0] + 170*par[0]
        g3d.camera_position[1] -= 50*forward[1] + 170*par[1]
        g3d.camera_yaw = 137 - math.degrees(math.atan2(forward[1], forward[0]))
        g3d.camera_pitch = 2
    else:
        g3d.camera_position = focus
        g3d.camera_position[2] += 90
        g3d.camera_position[0] -= (train.train_length + 70)*forward[0]
        g3d.camera_position[1] -= (train.train_length + 70)*forward[1]
        g3d.camera_yaw = 90 - math.degrees(math.atan2(forward[1], forward[0]))
        g3d.camera_pitch = 20


def update_train_mesh(init=False):
    """
    Update the mesh of the train and the camera position.
    """
    global train_mesh
    if init:
        train_mesh = g3d.mesh_new()
    cars = train.car_positions(train_position)

    # Camera
    if autoplay:
        front = cars[-2]
        back = cars[-1]
    else:
        front = cars[0]
        back = cars[1]
    par, per = parper2(back, front)
    update_camera([front[0], front[1], meshes.TRAIN_LEVEL], par)
    generate_train(cars, train_mesh)


def game():
    """
    This function is executed each game frame.
    """
    global power_lock, power_level, skipped

    handle_events()
    update_map()
    update_train()
    update_train_mesh()

    sect.update_stage(get_offset(), train_velocity)
    sect.tick_speeding(0.12 * train_velocity > speed_limit + 5)
    if sect.stage == section.S_OVERRUN:
        skipped = True
        ui.push_notification("You skipped a station!")
        sect.extend()
    elif sect.new_stage and sect.stage == section.S_STOPPED:
        power_lock = True
        power_level = -3
        game_time.freeze()

    draw()
    clock.tick(FPS)


def game_init(menu_mode=False):
    """
    Initialize the game.
    """
    global sigviol, session_score, autoplay, paused, pause_frozen
    sigviol = False
    if menu_mode:
        session_score = None
    else:
        session_score = score_history.new_session()
    autoplay = menu_mode

    game_time.reset()
    meshes.setup()
    update_map(True)
    update_train(True)
    update_train_mesh(True)
    g3d.render_wireframe = False
    paused = False
    pause_frozen = False


def game_finalize():
    """
    Reset all state associated with the game.
    """
    pause_game(False)
    railway.reset()
    g3d.reset()
    game_time.toggle_freeze(False)
    game_time.reset()
    ui.reset()


if __name__ == "__main__":
    random.seed()
    pygame.init()

    window = pygame.display.set_mode(WINDOW_SIZE)
    window_rect = window.get_rect()
    clock = pygame.time.Clock()

    overlay = pygame.Surface(window_rect.size)
    overlay.fill("white")
    overlay.set_alpha(220)

    score_history = scores.ScoreHistory()

    g3d.setup(window, window_rect)
    ui.setup(window, window_rect)
    train.setup([100, 120, 120, 100], 30)
    menu.setup(window, window_rect, score_history)

    last_playing = False
    playing = False
    while True:
        print("---")
        game_init(not playing)
        while playing == last_playing:
            game()
        game_finalize()
        if not playing:
            menu.setup_summary(score_history.current_session)
            score_history.end_session()
        last_playing = playing
